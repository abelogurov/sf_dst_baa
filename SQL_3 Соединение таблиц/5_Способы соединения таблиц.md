### 5. Способы соединения таблиц

### ОПЕРАТОРЫ

### INNER JOIN

INNER JOIN — это тот же JOIN (слово inner в операторе можно опустить).

Для INNER JOIN работает следующее правило: присоединяются только те строки таблиц, которые удовлетворяют условию соединения. Если в любой из соединяемых таблиц находятся такие строки, которые не удовлетворяют заявленному условию, — они отбрасываются.

Рассмотрим на примере нашего датасета. 

В таблице teams есть данные о 299 различных командах — можем проверить это с помощью запроса.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT 
2. COUNT(DISTINCT id) /*оператор подсчёта строк; оператор исключения повторяющихся строк; столбец id*/
3. FROM sql.teams /*таблица teams*/

или

1. SELECT 
2. COUNT(DISTINCT api_id) /*оператор подсчёта строк; оператор исключения повторяющихся строк; столбец api_id*/
3. FROM sql.teams

Теперь добавим к teams таблицу с матчами.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT 
2. COUNT(DISTINCT t.id) /*оператор подсчёта строк; оператор исключения повторяющихся строк; столбец id*/
3. FROM 
4. sql.teams t /*таблица teams с алиасом t*/
5. JOIN sql.matches m ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id /*оператор соединения inner JOIN; таблица teams с алиасом t; условие: home_team_api_id таблицы m равен api_id таблицы t или away_team_api_id таблицы m равен api_id таблицы t*/

И в таблице останется уже не 299 команд, а только 292.

Почему?

Дело в том, что таблица sql.matches по какой-то причине не содержит информацию о командах Lierse SK, KVC Westerlo, KAS Eupen, Club Brugge KV, KV Oostende, RSC Anderlecht и Hull City, зато они есть в таблице sql.teams. Возможно, эти команды не участвовали ни в одном матче или записи по этим матчам были удалены.

### LEFT OUTER JOIN И RIGHT OUTER JOIN

Также существуют схожие друг с другом типы соединения — LEFT JOIN и RIGHT JOIN (слово outer в операторе можно опустить).

Для LEFT JOIN работает следующее правило: из левой (относительно оператора) таблицы сохраняются все строки, а из правой добавляются только те, которые соответствуют условию соединения. Если в правой таблице не находится соответствия, то значения строк второй таблицы будут иметь значение NULL.

LEFT JOIN может быть полезен, когда соответствующих записей во второй таблице может не быть, но важно сохранить записи из первой таблицы.

Почему соответствий может не быть?

Причины могут быть разные, назовём две основные:

1. Различная бизнес-логика таблиц.

Пример: в интернет-магазине почти всегда можно оформить заказ с промокодом. Вполне вероятно, что информация о промокодах хранится в отдельной таблице, но при этом не для каждого заказа будет существовать промокод, поскольку покупку можно оформить и без него.

2. Разное время обновления таблиц.

Пример: клиент зарегистрировался на сайте интернет-магазина и оформил заказ. Данные о регистрации клиентов могут обновляться в базе данных раз в неделю, а о заказах — раз в сутки.

- Поставим следующую задачу: вывести полные названия команд, данных по которым нет в таблице matches.

Для начала посмотрим на результат запроса после соединения.

ПОПРОБУЙТЕ В METABASE!

1. SELECT
2.     t.long_name, /*столбец long_name таблицы t*/
3.     m.id /*столбец id таблицы m*/
4. FROM sql.teams t /*таблица teams с алиасом t*/
5. LEFT JOIN sql.matches m ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id /*оператор соединения left JOIN; таблица matches с алиасом m; условие: home_team_api_id таблицы m равен api_id таблицы t или away_team_api_id таблицы m равен api_id таблицы t*/
6. ORDER BY m.id DESC /*сортировка по id таблицы m по убыванию, чтобы увидеть строки со значением null*/

### Вывод: в таблице teams сохранились все записи, а в таблице matches есть пустые строки.

Теперь, чтобы выбрать такие команды, которые не принимали участия в матчах, достаточно добавить условие where m.id is null (или любое другое поле таблицы matches).

### ПОПРОБУЙТЕ В METABASE!

1. SELECT
2.     t.long_name /*столбец long_name таблицы t*/
3. FROM 
    sql.teams t /*таблица teams с алиасом t*/
4. LEFT JOIN sql.matches m ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id /*оператор соединения left JOIN; таблица matches с алиасом m; условие: home_team_api_id таблицы m равен api_id таблицы t или away_team_api_id таблицы m равен api_id таблицы t*/
5. WHERE m.id IS NULL /*условие: столбец id таблицы m имеет значение null*/

### Обратите внимание! Если мы добавим какой-либо фильтр по значению для таблицы matches, то LEFT JOIN превратится в INNER JOIN, поскольку для второй таблицы станет необходимым присутствие значения в строке.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT
2.     t.long_name /*столбец long_name таблицы t*/
3. FROM sql.teams t /*таблица teams с алиасом t*/
4. LEFT JOIN sql.matches m ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id /*оператор соединения left JOIN; таблица matches с алиасом m; условие: home_team_api_id таблицы m равен api_id таблицы t или away_team_api_id таблицы m равен api_id таблицы t*/
5. WHERE
    m.season = '2008/2009'  /*условие: столбец season таблицы m имеет значение 2008/2009*/
6. AND t.long_name = 'KAS Eupen' /*условие: столбец long_name таблицы t имеет значение KAS Eupen*/

В ответе Metabase получим No results!, так как вместе с фильтром m.season = '2008/2009' исчезли все строки, значения которых NULL.

### Задание 5.1

Используя LEFT JOIN, выведите список уникальных названий команд, содержащихся в таблице matches. Отсортируйте список в алфавитном порядке.

1. SELECT
2.     DISTINCT t.long_name
3. FROM sql.teams t
4. LEFT JOIN sql.matches m ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id
5. WHERE m.id is not null
6. ORDER BY 1

С LEFT JOIN также работают агрегатные функции, что позволяет не потерять значения из левой таблицы. Например, мы можем вывести сумму голов команд по гостевым матчам.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT
2.     t.long_name,
3.     SUM(m.away_team_goals) total_goals
4. FROM 
5.     sql.teams t /*таблица teams с алиасом t*/
6. LEFT JOIN sql.matches m ON t.api_id = m.away_team_api_id /*оператор соединения LEFT JOIN; таблица matches с алиасом m; условие: away_team_api_id таблицы m равен api_id таблицы t*/
7. GROUP BY t.id /*группировка по столбцу id таблицы t*/
8. ORDER BY 2 DESC /*сортировка по столбцу total_goals по убыванию, чтобы увидеть строки со значением null*/

### Обратите внимание! При применении функций SUM, MIN, MAX, AVG к полям со значением NULL в результате получится NULL, а не 0. А при использовании функции COUNT, наоборот, получится 0.

### Задание 5.2

Используя LEFT JOIN, напишите запрос, который выведет полное название команды (long_name), количество матчей, в которых участвовала команда, — домашних и гостевых (matches_cnt).
Отсортируйте по количеству матчей в порядке возрастания, затем по названию команды в алфавитном порядке.

1. SELECT
2.     t.long_name long_name,
3.     COUNT(m.id)
4. FROM   
5.     sql.teams t
6. LEFT JOIN sql.matches m ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id
7. GROUP BY t.id
8. ORDER BY 2, 1

При использовании RIGHT JOIN сохраняется та же логика, что и для LEFT JOIN, только за основу берётся правая таблица.

Чтобы из LEFT JOIN получить RIGHT JOIN, нужно просто поменять порядок соединения таблиц.

Вообще, применение RIGHT JOIN считается плохим тоном, так как язык SQL читается и пишется слева направо, а такой оператор усложняет чтение запросов.

### FULL OUTER JOIN

Оператор FULL OUTER JOIN объединяет в себе LEFT и RIGHT JOIN и позволяет сохранить кортежи обеих таблиц. Даже если не будет соответствий, мы сохраним все записи из обеих таблиц.

[FULL OUTER JOIN может быть полезен в ситуациях, когда схема данных недостаточно нормализована и не хватает таблиц-справочников.](https://drive.google.com/file/d/1G2zr3gm3D3x7J-vn3kgssSobg_BYJl5R/view?usp=sharing)

Пример: в базе данных интернет-магазина есть две таблицы — с зарегистрированными пользователями и пользователями, оформившими заказ. При этом оформить заказ можно без регистрации, а зарегистрироваться — без оформления заказа.

Предположим, что вам необходимо получить полный список пользователей — и оформивших заказ, и зарегистрированных, — но в базе данных этой объединённой таблицы нет. В данном случае можно использовать FULL OUTER JOIN для получения полного списка, соединив таким образом таблицы c заказами и регистрациями по id пользователя.

Синтаксис FULL OUTER JOIN аналогичен другим JOIN.

1. SELECT 
2. …
3. FROM
4. 	table1
5. FULL OUTER JOIN table2 ON условие

### CROSS JOIN

На самом деле с этим оператором соединения таблиц вы познакомились в самом начале текущего модуля.

[CROSS JOIN соединяет таблицы так, что каждая запись в первой таблице присоединяется к каждой записи во второй таблице, иначе говоря, даёт декартово произведение.](https://drive.google.com/file/d/1-q0ANHHGZHrh0hhgmVuu_6RkSF1zIHMQ/view?usp=sharing)

В начале модуля вы использовали этот оператор, записывая таблицы через запятую.

1. SELECT * /*выбор всех полей*/
2. FROM
3.     sql.teams, /*таблица teams*/
4.     sql.matches /*таблица matches*/

### Этот же запрос можно записать с использованием CROSS JOIN.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT * /*выбор всех полей*/
2. FROM
3.     sql.teams /*таблица teams*/
4.     CROSS JOIN sql.matches /*таблица matches*/

### Обратите внимание! Условие для CROSS JOIN, в отличие от других операторов, не требуется.

Также этот запрос можно записать с помощью INNER JOIN с условием on true — результат будет тот же.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT * /*выбор всех полей*/
2. FROM
3.     sql.teams /*таблица teams*/
4.     JOIN sql.matches ON TRUE /*оператор соединения INNER JOIN; таблица matches; условие: для всех случаев*/

CROSS JOIN может быть полезен, когда необходимо создать таблицу фактов.

Например, с помощью такого запроса мы можем получить все возможные комбинации полных названий команд в матчах.

ПОПРОБУЙТЕ В METABASE!

1. SELECT
2.     DISTINCT /*оператор исключения повторяющихся строк*/
3.     t1.long_name home_team, /*столбец long_name таблицы t1; новое название*/
4.     t2.long_name away_team /*столбец long_name таблицы t2; новое название*/
5. FROM
6.     sql.teams t1 /*таблица teams с алиасом t1*/
7.     CROSS JOIN sql.teams t2 /*оператор соединения CROSS JOIN; таблица teams с алиасом t2*/

### Задание 5.3

Напишите запрос, который выведет все возможные уникальные комбинации коротких названий домашней команды (home_team) и коротких названий гостевой команды (away_team).
Отсортируйте запрос по первому и второму столбцам.

1. SELECT
2.     DISTINCT
3.     t1.short_name home_team, 
4.     t2.short_name away_team
5. FROM
6.     sql.teams t1
7.     CROSS JOIN sql.teams t2
8.     ORDER BY 1,2

### NATURAL JOIN

Ключевое слово natural в начале оператора JOIN позволяет не указывать условие соединения таблиц — для соединения будут использованы столбцы с одинаковым названием из этих таблиц.

NATURAL JOIN можно использовать с любыми видами соединений, которые требуют условия соединения:

- NATURAL INNER JOIN (возможна запись NATURAL JOIN);
- NATURAL LEFT JOIN;
- NATURAL RIGHT JOIN;
- NATURAL FULL OUTER JOIN.

При использовании NATURAL JOIN прежде всего стоит обратить внимание на ключи таблиц. Для наших таблиц teams и matches этот вид соединения не подойдёт, так как общим для обеих таблиц является столбец id, но таблицы соединяются по другим столбцам.

Когда у таблиц есть несколько столбцов с одинаковыми именами, при NATURAL JOIN условие соединения будет применено на все столбцы с одинаковыми именами.

То есть для таблиц table1 и table2

table1: id, name, ...

table2: id, name, ...

### запрос

1. SELECT 
2. …
3. FROM 
4.          table1 
5. NATURAL JOIN table2

будет равнозначен запросу

1. SELECT
2. …
3. FROM 
4.          table1 t1
5. INNER JOIN table2 t2 ON t1.id = t2.id AND t1.name = t2.name

### ОБЩАЯ ЛОГИКА ПОСТРОЕНИЯ ЗАПРОСА С JOIN

При построении запроса с несколькими JOIN старайтесь идти слева направо. Сначала выберите таблицу, которая является центральной в соответствии с поставленной задачей, вопросом. Затем добавляйте таблицы поэтапно в зависимости от бизнес-логики запроса.

Например, для ответа на вопрос: «Какая команда сыграла больше всех матчей в сезоне 2010/2011?» в качестве центральной лучше выбрать таблицу с командами.

А для ответа на вопрос: «В каком сезоне участвовало больше всего команд?» — таблицу с матчами.

Стоит отметить, что из рассмотренных видов соединений чаще всего используются INNER JOIN и LEFT JOIN. Другие операторы используются реже, но стоит помнить об их существовании при решении нестандартных задач.

[ВИДЫ JOIN'ОВ](https://drive.google.com/file/d/1x2veDsKiGQqi4WRe4A4mYOQtOishnCGn/view?usp=sharing)