### 4. Фильтрация и агрегатные функции

РАБОТА С ОБЪЕДИНЁННЫМИ ТАБЛИЦАМИ

Соединять таблицы мы научились, теперь давайте научимся получать необходимые данные из нескольких таблиц

Принцип построения запроса и порядок операторов такой же, как и с обычной таблицей.

Вспомним его:

- SELECT... 
- FROM... 
- WHERE... 
- GROUP BY... 
- ORDER BY... 
- LIMIT...

### ФИЛЬТРАЦИЯ ДАННЫХ

К соединённым таблицам применимы функции фильтрации данных.

Например, можно вывести id матчей, в которых команда Arsenal была гостевой.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT 
2.     m.id /*столбец id таблицы m*/
3. FROM
4.     sql.teams t /*таблица teams с алиасом t*/
5.     JOIN sql.matches m ON m.away_team_api_id = t.api_id /*оператор соединения таблиц; таблица matches с алиасом m; условие: away_team_api_id таблицы m равен api_id таблицы t*/
6. WHERE long_name = 'Arsenal' /*long_name таблицы teams имеет значение Arsenal*/

Принципиальное отличие фильтрации данных по соединённым таблицам от аналогичного действия по одиночным таблицам заключается в том, что, фильтруя записи одной таблицы, мы также будем фильтровать и записи другой таблицы, поскольку соединённые на уровне запроса таблицы по сути являются единой таблицей.

Например, результат запроса

1. SELECT 
2. 	m.id id_1,
3. 	m.season,
4. 	t.id id_2,
5. 	t.long_name
6. FROM
7. 	sql.teams t
8. JOIN sql.matches m ON m.away_team_api_id = t.api_id

[можно разделить на две разные части](https://drive.google.com/file/d/1xslUtBsu5fRvgQzhnJkbkfaAh0gfxh7A/view?usp=sharing)

Одна часть — таблица matches с алиасом m, вторая — teams с алиасом t, но после соединения они являются одной таблицей.

Таким образом, если вы отфильтруете данные по одной части таблицы, то другая, соединённая, часть пропадёт вместе с ней.

### Задание 4.1

Напишите запрос, который выведет полное название команды (long_name), количество голов домашней команды (home_goal) и количество голов гостевой команды (away_goal) в матчах, где домашней командой были команды с коротким названием ‘GEN’. 
Отсортируйте запрос по id матча в порядке возрастания.

1. SELECT
2.     t.long_name long_name,
3.     m.home_team_goals home_goal,
4.     m.away_team_goals away_goal
5. FROM
6.     sql.matches m
7.     JOIN sql.teams t ON t.api_id = m.home_team_api_id 
8. WHERE short_name = 'GEN'
9. ORDER BY m.id

Также мы можем отфильтровать записи сразу по двум таблицам.

### ПОПРОБУЙТЕ В METABASE!

Например, можно оставить только записи, в которых короткое название домашней команды GEN и матчи сезона 2008/2009.

Также мы можем отфильтровать записи сразу по двум таблицам.

### ПОПРОБУЙТЕ В METABASE!

Например, можно оставить только записи, в которых короткое название домашней команды GEN и матчи сезона 2008/2009.

1. SELECT * /*выбор всех полей*/
2. FROM    
3.     sql.matches m /*таблица matches с алиасом m*/
4.     JOIN sql.teams t on t.api_id = m.home_team_api_id /*оператор соединения таблиц; таблица teams с алиасом t; условие: home_team_api_id таблицы m равен api_id таблицы t*/
5. WHERE
6.     t.short_name = 'GEN' /*столбец short_name таблицы t имеет значение GEN*/
7.     AND m.season = '2008/2009' /*столбец season таблицы m имеет значение 2008/2009*/

### Задание 4.2

Напишите запрос, чтобы вывести id матчей, короткое название домашней команды (home_short), короткое название гостевой команды (away_short) для матчей сезона 2011/2012, в которых участвовала команда с названием Liverpool.
Отсортируйте по id матча в порядке возрастания.

1. SSELECT
2.     m.id,
3.     t.short_name home_short,
4.     t1.short_name away_short
5. FROM
6.     sql.matches m
7.     JOIN sql.teams t ON t.api_id = m.home_team_api_id
8.     JOIN sql.teams t1 ON t1.api_id = m.away_team_api_id
9. WHERE (t.long_name = 'Liverpool' or t1.long_name = 'Liverpool')
10. AND m.season ='2011/2012'
11. ORDER BY m.id

### АГРЕГАЦИЯ ДАННЫХ

К соединённым таблицам также применимы любые агрегатные функции — самые важные функции для анализа данных.

### ПОПРОБУЙТЕ В METABASE!

Например, мы можем вывести сумму голов по командам для матчей, где команда выступала в гостях.

1. SELECT
2.     t.long_name, /*столбец long_name таблицы t*/
3.     SUM(m.home_team_goals) + SUM(m.away_team_goals) match_goals /*функция суммирования; столбец home_team_goals таблицы m; функция суммирования; столбец away_team_goals таблицы m; новое название столбца*/
4. FROM
5.     sql.matches m /*таблица matches с алиасом m*/
6.     JOIN sql.teams t ON m.away_team_api_id = t.api_id /*оператор соединения таблиц; таблица teams с алиасом t; условие: away_team_api_id таблицы m равен api_id таблицы t*/
7. GROUP BY t.id /*группировка по столбцу id таблицы t*/

### Обратите внимание! В данном запросе была использована группировка по столбцу id таблицы teams, хотя этот столбец не выводится в запросе. Это необходимо для того, чтобы команды с одинаковым названием, если такие найдутся, не группировались между собой. Группировка по названию команды в данном запросе будет неверной, так как есть несколько команд с одинаковым полным названием — мы говорили об этом в начале модуля.

Также, применяя агрегатные функции к соединённым таблицам, обращайте внимание на указание алиасов (или таблиц) при группировке и указании столбцов агрегатных функций. В нашей соединённой таблице есть два столбца с названием id, и если бы мы сформировали запрос без указания таблицы, как указано ниже, то...

### ПОПРОБУЙТЕ В METABASE!

1. SELECT
2.     t.long_name, /*столбец long_name таблицы t*/
3.     SUM(m.home_team_goals) + SUM(m.away_team_goals) match_goals /*функция суммирования; столбец home_team_goals таблицы m; функция суммирования; столбец away_team_goals таблицы m; новое название столбца*/
4. FROM
5.     sql.matches m /*таблица matches с алиасом m*/
6.     JOIN sql.teams t ON m.away_team_api_id = t.api_id /*оператор соединения таблиц; таблица teams с алиасом t; условие: away_team_api_id таблицы m равен api_id таблицы t*/
7. GROUP BY id /*группировка по столбцу id, но не указано, какой таблицы*/

### система выдала бы уже знакомую нам ошибку: "... column "id" is ambiguous ...".

Мы можем использовать оператор HAVING для фильтрации сгруппированных данных.

Поставим задачу — вывести таблицу с суммарным количеством забитых голов в матчах по командам и сезонам для команд, в которых суммарное количество голов в матчах сезона больше 100.


### ПОПРОБУЙТЕ В METABASE!

Для начала посчитаем общее количество голов в матчах по сезонам.

1. SELECT
2.     m.season, /*столбец season таблицы m*/
3.     SUM(m.home_team_goals) + SUM(m.away_team_goals) total_goals /*функция суммирования; столбец home_team_goals таблицы m; функция суммирования; столбец away_team_goals таблицы m; новое название столбца*/
4. FROM sql.matches m /*таблица matches с алиасом m*/
5. GROUP BY m.season /*группировка по столбцу season таблицы m*/

### ПОПРОБУЙТЕ В METABASE!

Затем добавим таблицу с командами, группировку по командам и условие фильтрации.

1. SELECT
2.     m.season, /*столбец season таблицы m*/
3.     t.long_name, /*столбец long_name таблицы t*/
4.     SUM(m.home_team_goals) + SUM(m.away_team_goals) total_goals /*функция суммирования; столбец home_team_goals таблицы m; функция суммирования; столбец away_team_goals таблицы m; новое название столбца*/
5. FROM sql.matches m /*таблица matches с алиасом m*/
6. JOIN sql.teams t ON t.api_id = m.home_team_api_id OR t.api_id = m.away_team_api_id /*оператор соединения таблиц; таблица teams с алиасом t; условие: home_team_api_id таблицы m равен api_id таблицы t или away_team_api_id таблицы m равен api_id таблицы t*/
7. GROUP BY m.season, t.id /*группировка по столбцам season таблицы m и id таблицы t*/
8. HAVING SUM(m.home_team_goals) + SUM(m.away_team_goals) > 100 /*оператор фильтрации сгруппированных данных; функция суммирования; home_team_goals таблицы m; функция суммирования; away_team_goals таблицы m; больше 100*/

### Задание 4.3

1 point possible (graded)
Напишите запрос, с помощью которого можно вывести список полных названий команд, сыгравших в гостях 150 и более матчей. 
Отсортируйте список по названию команды.

1. SELECT
2.     t.long_name
3. FROM sql.matches m
4. JOIN sql.teams t ON t.api_id = m.away_team_api_id
5. GROUP BY t.id
6. HAVING COUNT(*) >= 150
7. ORDER BY t.long_name