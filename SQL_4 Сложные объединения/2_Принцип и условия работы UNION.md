### 2. UNION

### ПРИНЦИП И УСЛОВИЯ РАБОТЫ UNION

Вернёмся к центральному вопросу модуля: как соединить несколько результатов, чтобы получить в выводе один общий?
В запросе мы использовали оператор UNION ALL — он присоединяет любой результат запроса к другому «снизу» при условии, что у них одинаковая структура, а именно:

- одинаковый тип данных;
- одинаковое количество столбцов;
- одинаковый порядок столбцов согласно типу данных.

### ВИДЫ UNION

Оператор присоединения существует в двух вариантах:

- UNION выводит только уникальные записи;
- UNION ALL присоединяет все строки последующих таблиц к предыдущим, без ограничений по уникальности.

### Важно! UNION оставляет только уникальные значения, а потому требует дополнительных вычислительных мощностей и памяти (в данном случае можно провести аналогию с DISTINCT). Поэтому если вы уверены в отсутствии дубликатов в данных или они вам не важны, предпочтительнее использовать UNION ALL.

Проверить, как различаются операторы, вы сможете при выполнении заданий 2.1 и 3.1.

### СИНТАКСИС

Запрос строится таким образом:

1. SELECT
2.          n columns
3. FROM 
4.          table_1

5. UNION ALL

6. SELECT 
7.          n columns
8. FROM 
9.          table_2
...

10. UNION ALL

11. SELECT 
12.          n columns
13. FROM 
14.          table_n

Результатом выполнения такого запроса будут строки table_1, table_2, ..., table_n, соединённые одни под другими и выведенные в единой выдаче.

### Важно! Названия итоговых колонок в выводе будут такие же, как в первом блоке SELECT, даже если они отличаются в других блоках подзапросов.

Пришла пора испытать функцию UNION(ALL) на практике.

Обратимся к нашему датасету о транспортной компании и посмотрим, как сформировать справочник с ID всех таблиц и указанием объекта, к которому он относится.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT
2.          c.city_id object_name,  'id города' object_type /*выбираем колонку city_id и задаём ей алиас object_name, сами задаём объект 'id города' и название столбца object_type*/
3. FROM 
4.          sql.city c /*из схемы sql и таблицы city, задаём алиас таблице — с*/

5. UNION ALL /*оператор присоединения*/

6. SELECT
7.          d.driver_id other_name,  'id водителя' other_type /*выбираем колонку driver_id и задаём ей алиас other_name, сами задаём объект 'id водителя' и название столбца other_type*/
8. FROM 
9.          sql.driver d  /*из схемы sql и таблицы driver, задаём алиас таблице — d*/

10. UNION ALL /*оператор присоединения*/

11. SELECT
12.          s.ship_id,  'id доставки' /*выбираем колонку ship_id, сами задаём объект 'id доставки'*/
13. FROM 
14.          sql.shipment s /*из схемы sql и таблицы shipment, задаём алиас таблице — s*/

15. UNION ALL /*оператор присоединения*/

16. SELECT
17.          c.cust_id,  'id клиента' /*выбираем колонку cust_id, сами задаём объект 'id клиента'*/
18. FROM 
19.          sql.customer c /*из схемы sql и таблицы customer, задаём алиас таблице — c*/

20. UNION ALL /*оператор присоединения*/

21. SELECT
22.          t.truck_id,  'id грузовика' /*выбираем колонку truck_id, сами задаём объект 'id грузовика'*/
23. FROM 
24.          sql.truck t /*из схемы sql и таблицы truck, задаём алиас таблице — t*/
25. ORDER BY 1 /*сортировка по первому столбцу*/

### Обратите внимание! Несмотря на исходные названия колонок other_name и other_type во втором подзапросе, в выводе мы получим названия, которые дали в первом блоке: object_name и object_type.

Другая особенность — в применении сортировки ORDER BY: она всегда будет относиться к итоговому результату всего запроса с UNION ALL.

В случаях, когда необходимо применить команду ORDER BY или LIMIT не к итоговому результату, а к каждой части запроса, можно обернуть подзапросы в скобки.

Чтобы посмотреть, как это работает, вернёмся к нашему примеру с общим справочником по фильмам и книгам.

Мы уже знаем, что можно легко и непринуждённо применить операторы ORDER BY и LIMIT ко всему результату запроса.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT book_name object_name, 'книга' object_descritption 
2. FROM public.books
3. UNION ALL
4. SELECT movie_title, 'фильм' 
5. FROM sql.kinopoisk
6. ORDER BY 1
7. LIMIT 1

Всё бы хорошо, только в таком случае отсортирован будет весь общий справочник, а в выводе останется одна строка с названием объекта, идущим первым по алфавиту.

А если мы не хотим общую сортировку? Может, нам нужны строки с названием как фильма, так и книги, идущих первыми по алфавиту.

Нет ничего проще — отсортируем каждую часть запроса по отдельности и объединим результаты!

### ПОПРОБУЙТЕ В METABASE!

Просто добавим ORDER BY и LIMIT ещё и в первую часть запроса:

1. SELECT book_name object_name, 'книга' object_descritption 
2. FROM public.books
3. ORDER BY 1
4. LIMIT 1
5. UNION ALL
6. SELECT movie_title, 'фильм' 
7. FROM sql.kinopoisk
8. ORDER BY 1
9. LIMIT 1

### Вместо результата получим сообщение о синтаксической ошибке: "...syntax error at or near "UNION"..." Очевидно, этот фокус не удался.

Не стоит огорчаться, ведь проблему можно решить одним (ну, почти) движением руки — просто добавив скобки вокруг каждой из частей запроса.

### ПОПРОБУЙТЕ В METABASE!

1. (SELECT book_name object_name, 'книга' object_descritption 
2. FROM public.books
3. ORDER BY 1
4. LIMIT 1)
5. UNION ALL
6. (SELECT movie_title, 'фильм' 
7. FROM sql.kinopoisk
8. ORDER BY 1
9. LIMIT 1)

Отлично! Мы получили именно то, что хотели.

### Важно! Если платформа не принимает ваш вариант кода, обращайте внимание на выпадающий пункт меню See full output: там иногда могут быть подсказки о причине ошибки.

### Задание 2.1

Напишите запрос, который создаёт уникальный алфавитный справочник всех городов, штатов, имён водителей и производителей грузовиков. 
Результатом запроса должны быть два столбца: название и тип объекта (city, state, driver, truck).
Отсортируйте список по названию объекта, а затем — по типу.

1. SELECT c.city_name "название", 'city' "тип объекта"
2. FROM sql.city c
3. UNION
4. SELECT c.state, 'state'
5. FROM sql.city c
6. UNION
7. SELECT d.first_name, 'driver' 
8. FROM sql.driver d
9. UNION
10. SELECT t.make, 'truck'
11. FROM sql.truck t
12. ORDER BY 1,2

### Задание 2.2

Напишите запрос, который соберёт имена всех упомянутых городов и штатов с таблицы city.
Результатом запроса должен быть один столбец object_name, отсортированный в алфавитном порядке.

1. 