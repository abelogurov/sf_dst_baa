### UNION и ручная генерация

Составим запрос, который позволит вывести первые три буквы алфавита и их порядковые номера.

### ПОПРОБУЙТЕ В METABASE!

1. SELECT 
2.          'a' letter,'1' ordinal_position /*сами задаём значение первого столбца ‘a’ и алиас для него letter, значение второго столбца ‘1’ и алиас для него ordinal_position*/
         
3. UNION /*оператор присоединения*/

4. SELECT 
5.          'b','2' /*сами задаём значение первого столбца ‘b’, значение второго столбца ‘2’ */
         
6. UNION /*оператор присоединения*/

7. SELECT
8.          'c','3' /*сами задаём значение первого столбца ‘с’, значение второго столбца ‘3’*/ 

Существуют сложные алгоритмы сравнения текстовых значений, но главный смысл сводится к одному: сравнение производится на основе таблицы unicode и позиции элемента в ней с учётом определённых условий.

### Задание 6.1

Напишите запрос, который выберет наибольшее из значений:

1000000;
541;
-500;
100.

1. SELECT 
2.     1000000::int numbers
3. UNION 
4. SELECT 
5.     541::int
6. UNION 
7. SELECT
8.     -500::int
9. UNION
10. SELECT
11.     100::int
12. GROUP BY 1
13. ORDER BY 1 DESC
14. LIMIT 1

### Задание 6.2

Мы помним, что сортировка для числовых и строковых типов данных отличается.
Построив запрос по аналогии с примером, приведите значения к текстовому типу данных, сравните и выберите наибольшее из них:

1000000;
541;
-500;
100.

1. SELECT 
2.     '1000000'
3. UNION 
4. SELECT 
5.     '541'
6. UNION 
7. SELECT
8.     '500'
9. UNION
10. SELECT
11.     '100'
12. GROUP BY 1
13. ORDER BY 1 DESC
14. LIMIT 1

### Задание 6.3

Построив запрос по аналогии с примером, найдите самое большое значение из перечисленных операторов:

+ ;
- ;
= ;
/ .

1. SELECT 
2.     '+'
3. UNION 
4. SELECT 
5.     '-'
6. UNION 
7. SELECT
8.     '='
9. UNION
10. SELECT
11.     '/'
12. GROUP BY 1
13. ORDER BY 1 DESC
14. LIMIT 1